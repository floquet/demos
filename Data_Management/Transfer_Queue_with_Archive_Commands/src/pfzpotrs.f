      SUBROUTINE PFZPOTRS( UPLO, N, NRHS, A, IA, JA, DESCA, B, IB, JB,
     $                     DESCB, INFO )
*
*
*  -- ScaLAPACK auxiliary routine (version 2.0) --
*     University of Tennessee, Knoxville, Oak Ridge National Laboratory,
*     and University of California, Berkeley.
*     Oct 10, 1996
*
*
*
*   Purpose
*  =======
*
*  PDPOTRS solves a system of linear equations
*
*                      sub( A ) * X = sub( B )
*          A(IA:IA+N-1,JA:JA+N-1)*X = B(IB:IB+N-1,JB:JB+NRHS-1)
*
*  where sub( A ) denotes A(IA:IA+N-1,JA:JA+N-1) and is a N-by-N
*  symmetric positive definite distributed matrix using the Cholesky
*  factorization sub( A ) = U**T*U or L*L**T computed by PDPOTRF.
*  sub( B ) denotes the distributed matrix B(IB:IB+N-1,JB:JB+NRHS-1).
*
*
*  Matrix A is stored in an out-of-core Matrix.
*
*  Cholesky factorization is  generated by PFxPOTRF().
*
*  See ScaLAPACK PPOTRS for more details.
*
*
*     .. Parameters ..
      INTEGER            BLOCK_CYCLIC_2D, DLEN_, DT_
      PARAMETER          ( BLOCK_CYCLIC_2D = 1, DLEN_ = 9, DT_ = 1 )
      INTEGER            CTXT_, MB_, NB_
      PARAMETER          ( CTXT_ = 2, MB_ = 5, NB_ = 6 )
      INTEGER            RSRC_, CSRC_
      PARAMETER          ( RSRC_ = 7, CSRC_ = 8 )
      INTEGER            IODEV_, SIZE_, DISK_BLOCK_CYCLIC_2D
      PARAMETER          ( IODEV_ = 10, SIZE_ = 11,
     $                   DISK_BLOCK_CYCLIC_2D = 601 )
      INTEGER            FLEN_
      PARAMETER          ( FLEN_ = 12 )
      INTEGER            LWORK
      PARAMETER          ( LWORK = 100*100 )
*     ..
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            IA, IB, INFO, JA, JB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER            DESCA( FLEN_ ), DESCB( DLEN_ )
      COMPLEX*16         A( * ), B( * )
*     ..
*     .. Local Scalars ..
      LOGICAL            ASIZEQUERY, HASWORK, ISUPPER, ISVALID
      INTEGER            ANEED, ASIZE, CSRC, ICONTXT, ICTXT, IDUMMY,
     $                   LOCP, LOCQ, M, MB, MM, MMB, MYPCOL, MYPROW, NB,
     $                   NN, NNB, NPCOL, NPROW, P0, Q0, RSRC, SAVEDT
      COMPLEX*16         ONE
*     ..
*     .. Local Arrays ..
      COMPLEX*16         WORK( LWORK )
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            NUMROC
      EXTERNAL           LSAME, NUMROC
*     ..
*     .. External Subroutines ..
      EXTERNAL           BLACS_GRIDINFO, CHK1MAT, LAIO_INFO, PCHK1MAT,
     $                   PFZTRSM, PXERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          DBLE, DCMPLX, MAX
*     ..
*     .. Executable Statements ..
*
*  Perform error checking.
*
      ONE = DCMPLX( DBLE( 1 ) )
      M = N
      INFO = 0
      ICTXT = DESCA( CTXT_ )
      CALL BLACS_GRIDINFO( DESCA( CTXT_ ), NPROW, NPCOL, MYPROW,
     $                     MYPCOL )
      IF( NPROW.EQ.-1 ) THEN
         INFO = -( 7*100+CTXT_ )
         RETURN
      ENDIF
      ICTXT = DESCB( CTXT_ )
      CALL BLACS_GRIDINFO( DESCB( CTXT_ ), NPROW, NPCOL, MYPROW,
     $                     MYPCOL )
      IF( NPROW.EQ.-1 ) THEN
         INFO = -( 11*100+CTXT_ )
         RETURN
      ENDIF
      ISVALID = ( LSAME( UPLO, 'U' ) .OR. LSAME( UPLO, 'L' ) )
      IF( .NOT.ISVALID ) THEN
         INFO = -1
         CALL PXERBLA( DESCA( CTXT_ ), 'PFZPOTRS', 1 )
         RETURN
      ENDIF
      SAVEDT = DESCA( DT_ )
      DESCA( DT_ ) = BLOCK_CYCLIC_2D
      CALL CHK1MAT( N, 2, N, 2, IA, JA, DESCA, 7, INFO )
      IF( INFO.NE.0 ) THEN
         CALL PXERBLA( DESCA( CTXT_ ), 'PFZPOTRS', 7 )
         RETURN
      ENDIF
      IDUMMY = 1
      CALL PCHK1MAT( N, 2, N, 2, IA, JA, DESCA, 7, IDUMMY, IDUMMY,
     $               IDUMMY, INFO )
      IF( INFO.NE.0 ) THEN
         CALL PXERBLA( DESCA( CTXT_ ), 'PFZPOTRS', 7 )
         RETURN
      ENDIF
      DESCA( DT_ ) = SAVEDT
      SAVEDT = DESCB( DT_ )
      DESCB( DT_ ) = BLOCK_CYCLIC_2D
      CALL CHK1MAT( N, 2, NRHS, 3, IB, JB, DESCB, 11, INFO )
      IF( INFO.NE.0 ) THEN
         CALL PXERBLA( DESCB( CTXT_ ), 'PFZPOTRS', 11 )
         RETURN
      ENDIF
      IDUMMY = 1
      CALL PCHK1MAT( N, 2, NRHS, 3, IB, JB, DESCB, 11, IDUMMY, IDUMMY,
     $               IDUMMY, INFO )
      IF( INFO.NE.0 ) THEN
         CALL PXERBLA( DESCB( CTXT_ ), 'PFZPOTRS', 11 )
         RETURN
      ENDIF
      DESCB( DT_ ) = SAVEDT
      IF( DESCA( DT_ ).NE.DISK_BLOCK_CYCLIC_2D ) THEN
         INFO = -( 7*100+DT_ )
         CALL PXERBLA( DESCA( CTXT_ ), 'PFZPOTRS', 7 )
         RETURN
      ENDIF
      INFO = 0
      CALL LAIO_INFO( DESCA( IODEV_ ), MM, NN, MMB, NNB, MB, NB, CSRC,
     $                RSRC, ICONTXT )
      IF( MB.NE.DESCA( MB_ ) ) THEN
         INFO = -( 7*100+MB_ )
      ENDIF
      IF( NB.NE.DESCA( NB_ ) ) THEN
         INFO = -( 7*100+NB_ )
      ENDIF
      IF( ICONTXT.NE.DESCA( CTXT_ ) ) THEN
         INFO = -( 7*100+CTXT_ )
      ENDIF
      IF( DESCA( RSRC_ ).NE.RSRC ) THEN
         INFO = -( 7*100+RSRC_ )
      ENDIF
      IF( DESCA( CSRC_ ).NE.CSRC ) THEN
         INFO = -( 7*100+CSRC_ )
      ENDIF
      IF( INFO.NE.0 ) THEN
         CALL PXERBLA( DESCA( CTXT_ ), 'PFZPOTRS', 7 )
         RETURN
      ENDIF
      HASWORK = ( N.GE.1 ) .AND. ( NRHS.GE.1 )
      IF( .NOT.HASWORK ) THEN
         RETURN
      ENDIF
      ISUPPER = LSAME( UPLO, 'U' )
*
*  check storage requirement.
*
      P0 = MYPROW
      Q0 = MYPCOL
      IF( ISUPPER ) THEN
* mmb x n panel
         LOCP = NUMROC( MMB, DESCA( MB_ ), MYPROW, P0, NPROW )
         LOCQ = NUMROC( N, DESCA( NB_ ), MYPCOL, Q0, NPCOL )
      ELSE
* m x nnb panel
         LOCP = NUMROC( M, DESCA( MB_ ), MYPROW, P0, NPROW )
         LOCQ = NUMROC( NNB, DESCA( NB_ ), MYPCOL, Q0, NPCOL )
      ENDIF
      ANEED = MAX( 1, LOCP*LOCQ )
      ASIZE = DESCA( SIZE_ )
      ASIZEQUERY = ( ASIZE.EQ.-1 )
      IF( ASIZE.LT.ANEED ) THEN
         A( 1 ) = ANEED
         INFO = -( 7*100+SIZE_ )
         IF( .NOT.ASIZEQUERY ) THEN
            CALL PXERBLA( DESCA( CTXT_ ), 'PFZPOTRS', 7 )
         ENDIF
         RETURN
      ENDIF
      IF( ISUPPER ) THEN
*
*
*        Solve sub( A ) * X = sub( B ) where sub( A ) = U^t*U.
*
*        Solve U^t*X = sub( B ), overwriting sub( B ) with X.
*
*
         CALL PFZTRSM( 'Left', 'Upper', 'C', 'Non-unit', N, NRHS, ONE,
     $                 A, IA, JA, DESCA, B, IB, JB, DESCB, WORK, LWORK,
     $                 INFO )
*
*
*        Solve U*X = sub( B ), overwriting sub( B ) with X.
*
*
         CALL PFZTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
     $                 NRHS, ONE, A, IA, JA, DESCA, B, IB, JB, DESCB,
     $                 WORK, LWORK, INFO )
      ELSE
*
*
*        Solve sub( A ) *X = sub( B ) where sub( A ) = L*L^t.
*
*        Solve L*X = sub( B ), overwriting sub( B ) with X.
*
*
         CALL PFZTRSM( 'Left', 'Lower', 'No transpose', 'Non-unit', N,
     $                 NRHS, ONE, A, IA, JA, DESCA, B, IB, JB, DESCB,
     $                 WORK, LWORK, INFO )
*
*
*        Solve L^t*X = sub( B ), overwriting sub( B ) with X.
*
*
         CALL PFZTRSM( 'Left', 'Lower', 'C', 'Non-unit', N, NRHS, ONE,
     $                 A, IA, JA, DESCA, B, IB, JB, DESCB, WORK, LWORK,
     $                 INFO )
      ENDIF
      RETURN
      END
